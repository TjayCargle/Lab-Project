{\rtf1\adeflang1025\ansi\ansicpg1252\uc1\adeff0\deff0\stshfdbch0\stshfloch0\stshfhich0\stshfbi0\deflang1033\deflangfe1042{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}{\f37\froman\fcharset238\fprq2 Times New Roman CE;}
{\f38\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f40\froman\fcharset161\fprq2 Times New Roman Greek;}{\f41\froman\fcharset162\fprq2 Times New Roman Tur;}{\f42\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}
{\f43\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f44\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f45\froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\f47\fswiss\fcharset238\fprq2 Arial CE;}
{\f48\fswiss\fcharset204\fprq2 Arial Cyr;}{\f50\fswiss\fcharset161\fprq2 Arial Greek;}{\f51\fswiss\fcharset162\fprq2 Arial Tur;}{\f52\fbidi \fswiss\fcharset177\fprq2 Arial (Hebrew);}{\f53\fbidi \fswiss\fcharset178\fprq2 Arial (Arabic);}
{\f54\fswiss\fcharset186\fprq2 Arial Baltic;}{\f55\fswiss\fcharset163\fprq2 Arial (Vietnamese);}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;
\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{
\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 Normal;}{\s1\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\outlinelevel0\rin0\lin0\itap0 
\rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 heading 1;}{\*\cs10 \additive \ssemihidden Default Paragraph Font;}{\*
\ts11\tsrowd\trftsWidthB3\trpaddl108\trpaddr108\trpaddfl3\trpaddft3\trpaddfb3\trpaddfr3\trcbpat1\trcfpat1\tblind0\tblindtype3\tscellwidthfts0\tsvertalt\tsbrdrt\tsbrdrl\tsbrdrb\tsbrdrr\tsbrdrdgl\tsbrdrdgr\tsbrdrh\tsbrdrv 
\ql \li0\ri0\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs20 \ltrch\fcs0 \fs20\lang1024\langfe1024\cgrid\langnp1024\langfenp1024 \snext11 \ssemihidden Normal Table;}}
{\*\latentstyles\lsdstimax156\lsdlockeddef0}{\*\rsidtbl \rsid599673\rsid3090344\rsid3606044\rsid4990169\rsid6291744\rsid6703762\rsid12462526\rsid13197366}{\*\generator Microsoft Word 11.0.8106;}{\info{\title Linear Algebra Labs (1-3)}
{\author Administrator}{\operator dfennar}{\creatim\yr2005\mo2\dy2\hr16\min9}{\revtim\yr2009\mo1\dy29\hr12\min5}{\version7}{\edmins41}{\nofpages5}{\nofwords1398}{\nofchars7970}{\*\company  }{\nofcharsws9350}{\vern24611}{\*\password 00000000}}
{\*\xmlnstbl {\xmlns1 http://schemas.microsoft.com/office/word/2003/wordml}}\paperw12240\paperh15840\margl1701\margr1701\margt1985\margb1701\gutter0\ltrsect 
\widowctrl\ftnbj\aenddoc\donotembedsysfont0\donotembedlingdata1\grfdocevents0\validatexml0\showplaceholdtext0\ignoremixedcontent0\saveinvalidxml0\showxmlerrors0\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\hyphcaps0\horzdoc\dghspace120
\dgvspace120\dghorigin1701\dgvorigin1984\dghshow0\dgvshow3\jcompress\viewkind4\viewscale100\nolnhtadjtbl\rsidroot4990169 \fet0{\*\wgrffmtfilter 013f}\ilfomacatclnup0\ltrpar \sectd \ltrsect\linex0\sectdefaultcl\sftnbj {\*\pnseclvl1
\pnucrm\pnqc\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl2\pnucltr\pnqc\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl3\pndec\pnqc\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl4\pnlcltr\pnqc\pnstart1\pnindent720\pnhang {\pntxta )}}
{\*\pnseclvl5\pndec\pnqc\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnqc\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnqc\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl8
\pnlcltr\pnqc\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnqc\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}\pard\plain \ltrpar\qc \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 
\ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \af0\afs32 \ltrch\fcs0 \fs32\insrsid13197366 Linear Algebra Labs}{\rtlch\fcs1 \af0\afs32 \ltrch\fcs0 \fs32\insrsid4990169 
\par }\pard \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 {\rtlch\fcs1 \af0\afs32 \ltrch\fcs0 \fs32\insrsid4990169 
\par }{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid4990169 Lab Assignment Rules:
\par 
\par IMPORTANT! YOU MUST READ!
\par \tab 
All work must be done independently. Copied work will result in a zero with a follow-up interview (including possible disciplinary action). DO NOT share your code with anybody. You may help your classmates. The best way to avoid copied code is to use verb
al communication and pencil and paper when helping your classmates.
\par 
\par }\pard \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0\pararsid4990169 {\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid4990169 \tab This lab assignment will be due by the end of lab}{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid6291744 
 on the last day of class}{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid4990169 . Your grade will be determined based on the validation}{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid6291744\charrsid6291744  }{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid6291744 results}{
\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid4990169 . The wireless network will have a folder in LA for you to submit your code. This is a blind write. You can\rquote 
t see any files written here. You can check with a lab instructor to make sure your code was submitted properly. Your code will be checked against all other submissions. Many functions may be simila
r, but copied code is easy to detect. We use programs that check for more than changing variable names. 
\par }\pard \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid4990169 
\par \tab In each lab you will be implementing a number of functions. Your grade will be based on the }{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid3606044 completion of }{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid599673 the ENTIRE lab}{\rtlch\fcs1 \af0 \ltrch\fcs0 
\insrsid3606044  with NO partial credit.  All functions }{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid599673 m}{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid3606044 ust validate }{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid3090344 for you }{\rtlch\fcs1 \af0 \ltrch\fcs0 
\insrsid3606044 to receive any points.}{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid4990169 
\par }{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid6291744 
\par 
\par }{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid4990169 END IMPORTANT MESSAGE!
\par 
\par Lab Assignment:
\par 
\par Getting Started
\par \tab From the wireless network, get a copy of the folder named Lab Project. You should make two copies, one to work on and one in case you delete something important.
\par Open the Lab Project.vcproj. You should do a Build/Rebuild All and make sure no errors or warnings have occurred.
\par 
\par Testing the Code
\par \tab Open Windows Explorer and navigate to the project you are working in. You should see EngineMath.cpp, EngineMath.h, Test.h, Test.cpp 
and other files. Click (Double Click) on the file named Check Work.cmd. After clicking this automatic script you should see some new text files (data.txt, result.txt). Open the result.txt file and you will see if the functions have been coded correctly. A
t this point, every function will have failed some test.
\par 
\par Working toward a perfect grade efficiently
\par \tab At the top of test.cpp you will notice an enumeration for the lab number. The constant integer Switch will control which functions are being tested. Set it to LAB1 for the first lab.
\par \tab The only file you will be editing is EngineMath.cpp. EngineMath.h contains the structure (union) definitions and functions you will be working with. You will notice helper functions to make your work easier.
\par 
\par }\pard \ltrpar\ql \fi-360\li1080\ri0\nowidctlpar\tx1080\wrapdefault\faauto\rin0\lin1080\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid4990169 1.\tab We will be usin
g a union for our TVECTOR. This allows you to get at the elements of a 4-element vector by using the member (.) operator or using array access. Example: TVECTOR temp; temp.e[2] = 0; temp.w = 0;  .
\par }\pard \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid4990169 
\par }\pard \ltrpar\ql \fi-360\li1080\ri0\nowidctlpar\tx1080\wrapdefault\faauto\rin0\lin1080\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid4990169 2.\tab 
After coding a few functions, do a CLEAN and REBUILD ALL. Then run the Check Work.cmd . You should see a drop in the number of failed commands in the result.txt file.
\par }\pard \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid4990169 
\par }\pard \ltrpar\ql \fi-360\li1080\ri0\nowidctlpar\tx1080\wrapdefault\faauto\rin0\lin1080\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid4990169 3.\tab If a command has failed and you are sure about your code. Check the values that cause
d the function to fail. You can also try erasing all your code and retyping it with a different approach.
\par }\pard \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 {\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid4990169 
\par Lab Assignment, Function by Function
\par 
\par We use a four-component vector. The last component, the w or e[3] is used to mark weather a TVECTOR object is a
 vector or a point in space. A vector will have the w component set to 0, while a point will have a w component of 1. You can always check here if you are unsure about the role of the w component in a function.
\par 
\par }\pard\plain \ltrpar\s1\ql \li0\ri0\keepn\nowidctlpar\wrapdefault\faauto\outlinelevel0\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\insrsid4990169 
Vector_IsEqual
\par }\pard\plain \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\insrsid4990169 
\par \tab }{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid4990169 You must check to see if ev
ery component in one vector is equal to each corresponding component in another vector. Due to round off error use the helper functions bool IsEqual(float a) and possibly bool IsZero(float a). All four components must match for equivalence.
\par 
\par }\pard\plain \ltrpar\s1\ql \li0\ri0\keepn\nowidctlpar\wrapdefault\faauto\outlinelevel0\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\insrsid4990169 
Vector_Add
\par }\pard\plain \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\insrsid4990169 
\par }{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid4990169 \tab M
ake a temporary TVECTOR and set each of its components equal to the sum of the corresponding components from the TVECTORs in the parameters. The w component should be added as well. You can use a for loop if you wish.
\par 
\par }\pard\plain \ltrpar\s1\ql \li0\ri0\keepn\nowidctlpar\wrapdefault\faauto\outlinelevel0\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\insrsid4990169 
Vector_Sub
\par }\pard\plain \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid4990169 
\par \tab Make a temporary TVECTOR and set each of its components equal to the difference of the corresponding components from the TVECTORs in the parameters. The w component should be subtracted as well. You can use a for loop if you wish.
\par 
\par }\pard\plain \ltrpar\s1\ql \li0\ri0\keepn\nowidctlpar\wrapdefault\faauto\outlinelevel0\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\insrsid4990169 
Vector_Scalar_Multiply
\par }\pard\plain \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\insrsid4990169 
\par }{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid4990169 \tab Make a temporary TVECTO
R and set each of its components equal to the product of the corresponding components from the TVECTOR v and float s in the parameters. The w component should be scaled as well. You can use a for loop if you wish.
\par 
\par }\pard\plain \ltrpar\s1\ql \li0\ri0\keepn\nowidctlpar\wrapdefault\faauto\outlinelevel0\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\insrsid4990169 
Vector_Negate
\par }\pard\plain \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\insrsid4990169 
\par \tab }{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid4990169 
Make a temporary TVECTOR and set each of its components equal to the negation of corresponding components from the TVECTOR in the parameters. The w component should be negated as well. You can use a for loop if you wish.
\par 
\par }\pard\plain \ltrpar\s1\ql \li0\ri0\keepn\nowidctlpar\wrapdefault\faauto\outlinelevel0\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\insrsid4990169 
Vector_Dot
\par }\pard\plain \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\insrsid4990169 
\par }{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid4990169 \tab Given two TVECTORs a and b, the dot product will be a single scalar number. 
\par a (Dot) b = a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w
\par Use this formula to make the results to return. You can use a for loop if you wish.
\par 
\par }\pard\plain \ltrpar\s1\ql \li0\ri0\keepn\nowidctlpar\wrapdefault\faauto\outlinelevel0\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\insrsid4990169 
Vector_Cross
\par }\pard\plain \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\insrsid4990169 
\par }{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid4990169 \tab The cross product of two vectors produces another vector perpendicular to both of the original vectors. The w component will not be used in this function. Just set it to 0. Here\rquote 
s the formula for the components of the new vector in pseudo-code.
\par result = a (Cross) b}{\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\insrsid4990169 
\par }{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid4990169 result.x = a.y * b.z - a.z * b.y
\par result.y = a.z * b.x - a.x * b.z
\par result.z = a.x * b.y - a.y * b.x
\par result.w = 0
\par 
\par }\pard\plain \ltrpar\s1\ql \li0\ri0\keepn\nowidctlpar\wrapdefault\faauto\outlinelevel0\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\insrsid4990169 
Vector_LengthSq
\par }\pard\plain \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid4990169 
\par \tab You need to calculate the magnitude squared of a vector using all 4-components.
\par Given TVECTOR a the magnitude squared would be:
\par Magnitude squared = a.x*a.x + a.y * a.y + a.z * a.z + a.w * a.w
\par A useful function is float powf(float base, float exp). You could also employ your dot product function. This function would almost never be called on a point object, but coding the w values makes the functions consistent.
\par 
\par }\pard\plain \ltrpar\s1\ql \li0\ri0\keepn\nowidctlpar\wrapdefault\faauto\outlinelevel0\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\insrsid4990169 
Vector_Length
\par }\pard\plain \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\insrsid4990169 
\par \tab }{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid4990169 You could call your previous function and take the square root of the result. Here is the standard square root function call.
\par float sqrtf(float number_to_take_square_root_of)
\par 
\par }\pard\plain \ltrpar\s1\ql \li0\ri0\keepn\nowidctlpar\wrapdefault\faauto\outlinelevel0\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\insrsid4990169 
Vector_Normalize
\par }\pard\plain \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\insrsid4990169 
\par \tab }{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid4990169 
To normalize a vector, divide each component by its Length. This function has two major pitfalls. The most common is checking for division by zero. If the length of the vector is zero simply return a vector with all zeros. When checking for zero length be
 
sure to use the IsZero function.  The second is recalculating the length of a vector after changing on of its components. Use a temp vector to work on or a temp float to get the magnitude once. The w component should be divided as well. This function woul
d almost never be called on a point object, but you never know.
\par 
\par }\pard\plain \ltrpar\s1\ql \li0\ri0\keepn\nowidctlpar\wrapdefault\faauto\outlinelevel0\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\insrsid4990169 
Vector_Homogenise
\par }\pard\plain \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\insrsid4990169 
\par \tab }{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid4990169 This function is called on point objects that were created in such a way that the w-component is not 1 but perhaps 2 or 3. We want to make sure the w-component get set back
 to 1 by dividing every component by the w-component. The only pitfall is if w-component happens to be zero or close to zero. Check this with the IsZero function. If it is zero return a TVECTOR with 0\rquote s for all of its component values.
\par 
\par }\pard\plain \ltrpar\s1\ql \li0\ri0\keepn\nowidctlpar\wrapdefault\faauto\outlinelevel0\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\insrsid4990169 
Vector_Maximize
\par }\pard\plain \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\insrsid4990169 
\par \tab }{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid4990169 T
his function will take the maximum of the x-component from the parameters and assign them to a new TVECTOR. You continue getting the maximum for the rest of the components. Use the helper function Max. Return the newly made TVECTOR.
\par 
\par }\pard\plain \ltrpar\s1\ql \li0\ri0\keepn\nowidctlpar\wrapdefault\faauto\outlinelevel0\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\insrsid4990169 
Vector_Minimize
\par }\pard\plain \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\insrsid4990169 
\par \tab }{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid4990169 This
 function will take the minimum of the x-component from the parameters and assign them to a new TVECTOR. You continue getting the minimum for the rest of the components. Use the helper function Min. Return the newly made TVECTOR.
\par }{\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\insrsid4990169 
\par 
\par }\pard\plain \ltrpar\s1\ql \li0\ri0\keepn\nowidctlpar\wrapdefault\faauto\outlinelevel0\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\insrsid4990169 
Vector_Average
\par }\pard\plain \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\insrsid4990169 
\par }{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid4990169 \tab Create 
a temp TVECTOR and set each of its components to an average of the parameters components. Such that TVECTOR temp will have a temp.x value of (v.x + w.x)/2. Continue for all components. Return the TVECTOR temp.
\par 
\par }\pard\plain \ltrpar\s1\ql \li0\ri0\keepn\nowidctlpar\wrapdefault\faauto\outlinelevel0\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\insrsid4990169 
Vector_AngleBetween
\par }\pard\plain \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\insrsid4990169 
\par \tab }{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid4990169 This function will be c
alled on vectors with varying w-components. You can use the functions you have made before with no problems. The only pitfall is to check both parameters for zero vectors. If this is the case then just return zero. The return value should be in degrees. U
se helper functions to make work easier. Here is the formula.
\par TVECTOR a, b.
\par Angle = inverse_cosine( ( a (DOT) b ) / ( Length(a) * Length(b) ) )
\par 
\par You will have to work with this one for a while. The inverse_cosine function is 
\par float acosf( float ). It returns an angle in radians so you will have to convert it to degrees before returning from this function. If you have problems, use temp variables between function calls.
\par 
\par }\pard\plain \ltrpar\s1\ql \li0\ri0\keepn\nowidctlpar\wrapdefault\faauto\outlinelevel0\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\insrsid4990169 
Vector_Component
\par }\pard\plain \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\insrsid4990169 
\par \tab }{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid4990169 Given two TVECTORs a and b. Find the distance that a points in b\rquote 
s direction. If b is a zero vector then just return 0. Otherwise, normalize b and return the dot product of a and b. This function will be called on vectors with varying w-components. You can use the functions you have made before with no problems.
\par 
\par }\pard\plain \ltrpar\s1\ql \li0\ri0\keepn\nowidctlpar\wrapdefault\faauto\outlinelevel0\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\insrsid4990169 
Vector_Project
\par }\pard\plain \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs24\alang1025 \ltrch\fcs0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\insrsid4990169 
\par \tab }{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid4990169 Given two TVECTORs a and b. You can use the previous function to find the distance a points in b\rquote 
s direction. You can multiply this by the normalized version of b and return that value. This function will be called on vectors with varying w-components. You can use the functions you have made before with no problems.
\par 
\par }{\rtlch\fcs1 \ab\af0 \ltrch\fcs0 \b\insrsid4990169 
\par 
\par }{\rtlch\fcs1 \ab\af0\afs32 \ltrch\fcs0 \b\fs32\insrsid4990169 For lab sections 2 and 3, change the constant integer Switch to a new value. Glance at these functions before going to lecture. The comments should tell you what to do in special situations.

\par 
\par }{\rtlch\fcs1 \ab\af0\afs32 \ltrch\fcs0 \b\fs32\ul\cf6\insrsid4990169 Do not share your code with anyone. Being able to code these functions is considered basic knowledge that everyone in the game programming industry should have. 
\par }{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid4990169 
\par 
\par }{\rtlch\fcs1 \af1\afs20 \ltrch\fcs0 \fs20\hich\af1\insrsid4990169 
\par }}